<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Sphere</title>
  </head>
  <body>
    <canvas id="canvas" width="640px" height="480px"></canvas>
    <script src="../js/webgl.js"></script>
    <script src="../js/Vector3.js"></script>
    <script src="../js/Matrix4x4.js"></script>
    <script src="../js/geometry.js"></script>
    <script>
      document.addEventListener('DOMContentLoaded', () => {

        const vertexSource = `#version 300 es  
layout (location = 0) in vec3 position;
layout (location = 1) in vec3 normal;
layout (location = 2) in vec3 uv;

out vec3 v_normal;
out vec2 v_uv;

uniform mat4 u_mvpMatrix;

void main(void) {
  v_normal = normal;
  v_uv = v_uv;
  gl_Position = u_mvpMatrix * vec4(position, 1.0);
}
`
        
        const fragmentSource = `#version 300 es
precision highp float;

in vec3 v_normal;
in vec2 v_uv;

out vec4 o_color;


vec3 materialColor = vec3(0.95, 0.5, 0.5);
vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
vec3 lightColor = vec3(1.0);
vec3 ambient = vec3(0.1);

void main(void) {
  vec3 normal = normalize(v_normal);

  vec3 diffuse = materialColor * lightColor * max(0.0, dot(normal, lightDir));

  vec3 color = ambient + diffuse;

  o_color = vec4(color, 1.0);

}
`

        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2');

        const program = webgl.createProgram(gl, vertexSource, fragmentSource);

        const sphere = geometry.sphere(1.0, 16, 32);

        const ibo = webgl.createIbo(gl, sphere.indices);
        const positionVbo = webgl.createVbo(gl, sphere.positions);
        const normalVbo = webgl.createVbo(gl, sphere.normals);
        const uvVbo = webgl.createVbo(gl, sphere.uvs);

        const vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
        gl.bindBuffer(gl.ARRAY_BUFFER, positionVbo);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, normalVbo);
        gl.enableVertexAttribArray(1);
        gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, uvVbo);
        gl.enableVertexAttribArray(2);
        gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);  
        gl.bindVertexArray(null);

        const uniformLocations = webgl.getUniformLocations(gl, program, ['u_mvpMatrix']);

        const cameraTarget = new Vector3(0.0, 0.0, 0.0);
        const cameraPosition = new Vector3(0.0, 0.0, 5.0);
        const cameraUp = new Vector3(0.0, 1.0, 0.0);
        const cameraMatrix = Matrix4x4.translation(cameraPosition.x, cameraPosition.y, cameraPosition.z)
                                      .mult(Matrix4x4.lookTo(Vector3.sub(cameraTarget, cameraPosition), cameraUp));
        const viewMatrix = Matrix4x4.inverse(cameraMatrix);
        const projectionMatrix = Matrix4x4.perspective(canvas.width / canvas.height, 60, 0.01, 1000);

        const mvpMatrix = Matrix4x4.identity().mult(viewMatrix).mult(projectionMatrix);

        gl.clearColor(0.7, 0.7, 0.7, 1.0);
        gl.clearDepth(1.0);

        gl.enable(gl.DEPTH_TEST);

        const render = () => {
          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
          gl.useProgram(program);
          gl.uniformMatrix4fv(uniformLocations['u_mvpMatrix'], false, mvpMatrix.elements);
          gl.bindVertexArray(vao);
          gl.drawElements(gl.TRIANGLES, sphere.indices.length, gl.UNSIGNED_SHORT, 0);
          requestAnimationFrame(render);
        }
        render();
      });
    </script>
  </body>
</html>